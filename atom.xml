<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唧唧歪歪的河马正在打游戏</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mapeiyu.com/"/>
  <updated>2017-02-13T08:15:10.937Z</updated>
  <id>http://mapeiyu.com/</id>
  
  <author>
    <name>马培羽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>吐槽</title>
    <link href="http://mapeiyu.com/2017/02/13/tu-cao/"/>
    <id>http://mapeiyu.com/2017/02/13/tu-cao/</id>
    <published>2017-02-13T08:13:09.000Z</published>
    <updated>2017-02-13T08:15:10.937Z</updated>
    
    <content type="html"><![CDATA[<p>人如果不时常问问自己内心，那就会处于一种浑浑噩噩的状态。我就时常这样,偶尔清醒过来嘀咕两句，随后又甘心沉沦进去。然而心中却依然怀揣的自认为是理想的白日梦，以便于沉沦的心安理得。</p>
<p>我想到一个词“惰性”，人都有惰性。拷问自己本身就是一件痛苦的事。忙碌有时也是一种惰性，很多人忙碌并不是勤劳，仅仅是因为习惯了忙碌。习惯是一种让人舒服的状态，也是一种惰性。 </p>
<p>生活的状态其实都很随性的，没有一种标准定义什么是好与不好。但财富，在肤浅的层面上却能给人最直观的判断。不要理解的过于深刻，此处财富就是通俗意义上的money。财富好处不言自明。人总共就两种欲望，物质层面与精神层面。财富在这两个方面都能满足。</p>
<p>曾经，甚至我在混沌状态中还在模糊的意识中认为钱不是问题，老子有的是时间。真的以为“赚他一个亿”其实也不是什么笑话。一个亿？也不多嘛。可是细细算个帐下来，哪怕把这个任务均分到30年，每天都需要1万的进帐。貌似有点遥远。</p>
<p>唉！不禁感慨，现实就是这么赤裸裸。目标总是可望不可及。理想在现实面前就是一坨金黄的，诱人的镶了金边的屎。你要前行，却有各方向的力在拉扯，最终不知道要被带向何方。幸福是什么？温暖是什么？不知道。我是一艘在风雨中摇拽的船，没有港湾。</p>
<p>有些人把感恩记在本子上，记录生活中点滴的美好，它的心中充满阳光，甚至照亮了周围。有些却把缺憾记在本子上，记录美好生活中的点滴缺点，时不时拿来回味咀嚼，偿到苦处就破口大骂。或许根源在于自私吧，整天想着自己，整个人就会被黑暗笼罩。心存善念的面对别人，才会让心情阳光明媚。</p>
<p>套几句歌词以自勉，因为我只是在胡扯。</p>
<p><center>该不该搁下重重的壳</center></p>
<p><center>寻找到底哪里有蓝天</center></p>
<p><center>随着轻轻的风轻轻地飘</center></p>
<p><center>历经的伤都不感觉疼</center></p>
<p><center>我要一步一步往上爬</center></p>
<p><center>等待阳光静静看着它的脸</center></p>
<p><center>小小的天有大大的梦想</center></p>
<p><center>重重的壳裹着轻轻地仰望</center></p>
<p><center>我要一步一步往上爬</center></p>
<p><center>在最高点乘着叶片往前飞</center></p>
<p><center>小小的天流过的泪和汗</center></p>
<p><center>总有一天我有属于我的天</center></p>
<p><center><img src="/2017/02/13/tu-cao/timg.jpeg" alt="云淡风轻"></center></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人如果不时常问问自己内心，那就会处于一种浑浑噩噩的状态。我就时常这样,偶尔清醒过来嘀咕两句，随后又甘心沉沦进去。然而心中却依然怀揣的自认为是理想的白日梦，以便于沉沦的心安理得。&lt;/p&gt;
&lt;p&gt;我想到一个词“惰性”，人都有惰性。拷问自己本身就是一件痛苦的事。忙碌有时也是一种惰
    
    </summary>
    
    
      <category term="随笔" scheme="http://mapeiyu.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>groovy closure</title>
    <link href="http://mapeiyu.com/2017/02/13/groovy-closure/"/>
    <id>http://mapeiyu.com/2017/02/13/groovy-closure/</id>
    <published>2017-02-13T03:18:28.000Z</published>
    <updated>2017-02-13T06:14:55.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>闭包是可以用作函数参数和方法参数的代码块. 其实Groovy的闭包更象是一个“代码块”或者方法指针，代码在某处被定义然后在其后的调用处执行</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def square = &#123;it * it&#125; // 定义一个叫square的闭包。it是默认的 参数名称</div><div class="line">assert 4 == square(2) // 使用闭包</div><div class="line">assert [1,4,9] == [1,2,3].collect(square) // 使用闭包</div><div class="line"></div><div class="line">def closure = &#123; param -&gt; println(&quot;hello $&#123;param&#125;&quot;) &#125;</div><div class="line">closure.call(&quot;world!&quot;)</div><div class="line"> </div><div class="line">def closure = &#123; greeting, name -&gt; println(greeting + name) &#125;</div><div class="line">closure.call(&quot;hello &quot;, &quot;world!&quot;)</div></pre></td></tr></table></figure>
<p>闭包用“{}”括起，“-&gt;”前面是参数，后面是处理语句，可以直接调用，也可以使用call调用。不管那种调用，最后groovy编译器都会把编译成对doCall方法的调用，这是groovy对闭包的一个隐藏方法。如果只有一个参数，可以不写，而使用缺省的参数“it”。 如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def closure = &#123; println(&quot;hello $&#123;it&#125;&quot;) &#125;</div><div class="line">closure.call(&quot;world!&quot;)</div></pre></td></tr></table></figure>
<p>闭包还可当作变量返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def localMethod() &#123;</div><div class="line">  def localVariable = new java.util.Date()</div><div class="line">  return &#123; println localVariable &#125;</div><div class="line">&#125;</div><div class="line">def clos = localMethod()</div><div class="line">clos()</div></pre></td></tr></table></figure>
<h2 id="Groovy闭包的隐含变量"><a href="#Groovy闭包的隐含变量" class="headerlink" title="Groovy闭包的隐含变量"></a>Groovy闭包的隐含变量</h2><ul>
<li>it：默认的参数名，调用是如果没有传参数，it为null</li>
<li>this : 跟Java一样，是定义闭包所在类的一个引用，不管有多少层闭包嵌套，this指向的都是最上层的类。</li>
<li>owner : 封闭闭包的对象(如果只有一层闭包就是this，如果有多层闭包嵌套就是含有此闭包的上层闭包)</li>
<li>delegate :缺省值是owner，但是可以改变，后面详说。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class Class1 &#123;</div><div class="line">  def closure = &#123;</div><div class="line">    println &quot; ============================== &quot;</div><div class="line">    println &quot;this = &quot;+ this.class.name</div><div class="line">    println &quot;owner = &quot; + owner.class.name</div><div class="line">    println &quot;delegate = &quot; + delegate.class.name</div><div class="line">    def nestedClos = &#123;</div><div class="line">        println &quot; ============================== &quot;</div><div class="line">        println &quot;this = &quot;+ this.class.name</div><div class="line">        println &quot;owner = &quot; + owner.class.name</div><div class="line">        println &quot;delegate = &quot; + delegate.class.name</div><div class="line">      def thirdClos = &#123;</div><div class="line">            println &quot; ============================== &quot;</div><div class="line">            println &quot;this = &quot;+ this.class.name</div><div class="line">            println &quot;owner = &quot; + owner.class.name</div><div class="line">            println &quot;delegate = &quot; + delegate.class.name</div><div class="line">      &#125;</div><div class="line">      thirdClos()  </div><div class="line">    &#125;</div><div class="line">    nestedClos()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">def clos = new Class1().closure</div><div class="line">//clos.delegate = this</div><div class="line">clos()</div><div class="line">执行结果：</div><div class="line"> ============================== </div><div class="line">this = Class1</div><div class="line">owner = Class1</div><div class="line">delegate = Class1</div><div class="line"> ============================== </div><div class="line">this = Class1</div><div class="line">owner = Class1$_closure1</div><div class="line">delegate = Class1$_closure1</div><div class="line"> ============================== </div><div class="line">this = Class1</div><div class="line">owner = Class1$_closure1_closure2</div><div class="line">delegate = Class1$_closure1_closure2</div></pre></td></tr></table></figure>
<h2 id="闭包实现接口"><a href="#闭包实现接口" class="headerlink" title="闭包实现接口"></a>闭包实现接口</h2><ul>
<li>如果接口只有一个方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">interface Test</div><div class="line">&#123;</div><div class="line"> def test()</div><div class="line">&#125;</div><div class="line"></div><div class="line">def test = &#123;</div><div class="line"> println&apos;ok&apos;</div><div class="line">&#125; as Test</div><div class="line"></div><div class="line">test.test()</div></pre></td></tr></table></figure>
<ul>
<li>多方法接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">interface MultiFuncTest</div><div class="line">&#123;</div><div class="line">    def test1()</div><div class="line">    def test2(str)</div><div class="line">&#125;</div><div class="line"> </div><div class="line">def impl = [test1:&#123;println&apos;test&apos;&#125;,</div><div class="line">        test2:&#123;str -&gt; println str&#125;] as MultiFuncTest</div><div class="line"></div><div class="line">impl.test1()</div><div class="line">impl.test2(&apos;ok&apos;)</div></pre></td></tr></table></figure>
<h2 id="delegate委托"><a href="#delegate委托" class="headerlink" title="delegate委托"></a>delegate委托</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Dog&#123;</div><div class="line">    def play = &#123;</div><div class="line">      &quot;wang wang!&quot;</div><div class="line">    &#125;</div><div class="line">    def childmind = &#123;</div><div class="line">        println       delegate.play();      </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">class Cat &#123;</div><div class="line">    def play = &#123;&quot;mi mi !&quot;&#125;</div><div class="line">&#125;</div><div class="line">def dog = new Dog()</div><div class="line">def cat = new Cat()</div><div class="line">dog.childmind()</div><div class="line">dog.childmind.delegate  = cat;</div><div class="line">dog.childmind()</div></pre></td></tr></table></figure>
<p><center>OVER! 福利来喽!</center></p>
<p><center><img src="/2017/02/13/groovy-closure/11.jpg" alt="料"></center></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;闭包是可以用作函数参数和方法参数的代码块. 其实Groovy的闭包更象是一个“代码块”或者方法指针，代码在某处被定义然后在其后的调用处执行&lt;
    
    </summary>
    
      <category term="gradle开发" scheme="http://mapeiyu.com/categories/gradle%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="groovy" scheme="http://mapeiyu.com/tags/groovy/"/>
    
      <category term="gradle" scheme="http://mapeiyu.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>反射工具reflect更新到2.2.0版本(有重料)</title>
    <link href="http://mapeiyu.com/2017/02/09/reflect-update-2-2-0/"/>
    <id>http://mapeiyu.com/2017/02/09/reflect-update-2-2-0/</id>
    <published>2017-02-09T06:46:38.000Z</published>
    <updated>2017-02-13T06:16:44.224Z</updated>
    
    <content type="html"><![CDATA[<p>增加反射interface的实例化支持. 还添加了中文文档说明哦。</p>
<p><a href="https://github.com/masonTool/reflect" target="_blank" rel="external">点我传送门</a>  </p>
<p><center><img src="/2017/02/09/reflect-update-2-2-0/JYEY6NH06E91.jpg" alt="我有料"></center><br>额，我是料!!</p>
<p><center><img src="/2017/02/09/reflect-update-2-2-0/jinguanzhang.jpg" alt=""></center></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;增加反射interface的实例化支持. 还添加了中文文档说明哦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/masonTool/reflect&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我传送门&lt;/a&gt;  &lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="原创组件" scheme="http://mapeiyu.com/categories/%E5%8E%9F%E5%88%9B%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="java" scheme="http://mapeiyu.com/tags/java/"/>
    
      <category term="android" scheme="http://mapeiyu.com/tags/android/"/>
    
      <category term="reflect" scheme="http://mapeiyu.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>RX操作符概述</title>
    <link href="http://mapeiyu.com/2016/11/07/rx-operation/"/>
    <id>http://mapeiyu.com/2016/11/07/rx-operation/</id>
    <published>2016-11-07T10:43:34.000Z</published>
    <updated>2017-02-13T06:14:05.856Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveX的每种编程语言的实现都实现了一组操作符的集合。不同的实现之间有很多重叠的部分，也有一些操作符只存在特定的实现中。每种实现都倾向于用那种编程语言中他们熟悉的上下文中相似的方法给这些操作符命名。</p>
<p>本文首先会给出ReactiveX的核心操作符列表和对应的文档链接，后面还有一个决策树用于帮助你根据具体的场景选择合适的操作符。最后有一个语言特定实现的按字母排序的操作符列表。</p>
<p>如果你想实现你自己的操作符，可以参考这里：实现自定义操作符</p>
<p>创建操作</p>
<p>用于创建Observable的操作符</p>
<p>Create — 通过调用观察者的方法从头创建一个Observable<br>Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable<br>Empty/Never/Throw — 创建行为受限的特殊Observable<br>From — 将其它的对象或数据结构转换为Observable<br>Interval — 创建一个定时发射整数序列的Observable<br>Just — 将对象或者对象集合转换为一个会发射这些对象的Observable<br>Range — 创建发射指定范围的整数序列的Observable<br>Repeat — 创建重复发射特定的数据或数据序列的Observable<br>Start — 创建发射一个函数的返回值的Observable<br>Timer — 创建在一个指定的延迟之后发射单个数据的Observable<br>变换操作</p>
<p>这些操作符可用于对Observable发射的数据进行变换，详细解释可以看每个操作符的文档</p>
<p>uffer — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个<br>latMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。<br>roupBy — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据<br>ap — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项<br>can — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值<br>indow — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集<br>过滤操作</p>
<p>这些操作符用于从Observable发射的数据中进行选择</p>
<p>Debounce — 只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作<br>Distinct — 去重，过滤掉重复数据项<br>ElementAt — 取值，取特定位置的数据项<br>Filter — 过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的<br>First — 首项，只发射满足条件的第一条数据<br>IgnoreElements — 忽略所有的数据，只保留终止通知(onError或onCompleted)<br>Last — 末项，只发射最后一条数据<br>Sample — 取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst<br>Skip — 跳过前面的若干项数据<br>SkipLast — 跳过后面的若干项数据<br>Take — 只保留前面的若干项数据<br>TakeLast — 只保留后面的若干项数据<br>组合操作</p>
<p>组合操作符用于将多个Observable组合成一个单一的Observable</p>
<p>And/Then/When — 通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集<br>CombineLatest — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然- 后发射这个函数的结果<br>Join — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射<br>Merge — 将两个Observable发射的数据组合并成一个<br>StartWith — 在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项<br>Switch — 将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据<br>Zip — 打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射<br>错误处理</p>
<p>这些操作符用于从错误通知中恢复</p>
<p>Catch — 捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复<br>Retry — 重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止<br>辅助操作</p>
<p>一组用于处理Observable的操作符</p>
<p>Delay — 延迟一段时间发射结果数据<br>Do — 注册一个动作占用一些Observable的生命周期事件，相当于Mock某个操作<br>Materialize/Dematerialize — 将发射的数据和通知都当做数据发射，或者反过来<br>ObserveOn — 指定观察者观察Observable的调度程序（工作线程）<br>Serialize — 强制Observable按次序发射数据并且功能是有效的<br>Subscribe — 收到Observable发射的数据和通知后执行的操作<br>SubscribeOn — 指定Observable应该在哪个调度程序上执行<br>TimeInterval — 将一个Observable转换为发射两个数据之间所耗费时间的Observable<br>Timeout — 添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知<br>Timestamp — 给Observable发射的每个数据项添加一个时间戳<br>Using — 创建一个只在Observable的生命周期内存在的一次性资源<br>条件和布尔操作</p>
<p>这些操作符可用于单个或多个数据项，也可用于Observable</p>
<p>All — 判断Observable发射的所有的数据项是否都满足某个条件<br>Amb — 给定多个Observable，只让第一个发射数据的Observable发射全部数据<br>Contains — 判断Observable是否会发射一个指定的数据项<br>DefaultIfEmpty — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据<br>SequenceEqual — 判断两个Observable是否按相同的数据序列<br>SkipUntil — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据<br>SkipWhile — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据<br>TakeUntil — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知<br>TakeWhile — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据<br>算术和聚合操作</p>
<p>这些操作符可用于整个数据序列</p>
<p>Average — 计算Observable发射的数据序列的平均值，然后发射这个结果<br>Concat — 不交错的连接多个Observable的数据<br>Count — 计算Observable发射的数据个数，然后发射这个结果<br>Max — 计算并发射数据序列的最大值<br>Min — 计算并发射数据序列的最小值<br>Reduce — 按顺序对数据序列的每一个应用某个函数，然后返回这个值<br>Sum — 计算并发射数据序列的和<br>连接操作</p>
<p>一些有精确可控的订阅行为的特殊Observable</p>
<p>Connect — 指示一个可连接的Observable开始发射数据给订阅者<br>Publish — 将一个普通的Observable转换为可连接的<br>RefCount — 使一个可连接的Observable表现得像一个普通的Observable<br>Replay — 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅<br>转换操作</p>
<p>To — 将Observable转换为其它的对象或数据结构<br>Blocking 阻塞Observable的操作符<br>操作符决策树</p>
<p>几种主要的需求</p>
<p>直接创建一个Observable（创建操作）<br>组合多个Observable（组合操作）<br>对Observable发射的数据执行变换操作（变换操作）<br>从Observable发射的数据中取特定的值（过滤操作）<br>转发Observable的部分值（条件/布尔/过滤操作）<br>对Observable发射的数据序列求值（算术/聚合操作）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactiveX的每种编程语言的实现都实现了一组操作符的集合。不同的实现之间有很多重叠的部分，也有一些操作符只存在特定的实现中。每种实现都倾向于用那种编程语言中他们熟悉的上下文中相似的方法给这些操作符命名。&lt;/p&gt;
&lt;p&gt;本文首先会给出ReactiveX的核心操作符列表和
    
    </summary>
    
      <category term="RX" scheme="http://mapeiyu.com/categories/RX/"/>
    
    
      <category term="java" scheme="http://mapeiyu.com/tags/java/"/>
    
      <category term="RX" scheme="http://mapeiyu.com/tags/RX/"/>
    
  </entry>
  
  <entry>
    <title>不做工作狂</title>
    <link href="http://mapeiyu.com/2016/10/15/Workaholism/"/>
    <id>http://mapeiyu.com/2016/10/15/Workaholism/</id>
    <published>2016-10-15T14:39:58.000Z</published>
    <updated>2017-02-13T06:13:36.748Z</updated>
    
    <content type="html"><![CDATA[<p>我们的文化颂扬工作狂思想。我们听说人们会午夜鏖战。他们开夜车而在办公室睡觉。 这被认为是一种把全身投入一个项目的标志。工作的总量不等于过量的工作。<br>这样的工作狂不仅没必要,而且很傻。做得多并不意味着你足够用心或者完成得更多。仅仅意味着你做得多。</p>
<p>工作狂最后制造的麻烦比解决的麻烦多。首先,工作狂好似没有合理利用时间。当筋疲力尽时,会制造更多麻烦。工作狂也抓不住要点。他们想用砸大把大把的时间来解决事情。他们想用蛮干来弥补一些小技巧。结果就是粗野的解决。</p>
<p>他们甚至会制造危机。他们不会去找高效的方法因为他们确实喜欢加班。他们享受英雄般的感觉。他们制造出问题(通常是无意识地)以便多多工作。工作狂若是不留到很晚会觉得仅仅花合理的时间工作是不合理的。这会四处充满内疚感和低士气。并且,产生理所当然的想法──留守很晚是职责之外的事,就算他们不是真的富有成效。<br>如果你所做的都是工作,你不太可能得到很好的评价。你的价值和决定会以误解告终。你不能判断额外的努力是值得还是不值得。你只会彻底累垮。没有人能疲倦中做出明晰的决定。<br>  最后,工作狂并不比非工作狂达成更多目标。他们也许会宣称自己是完美主义者,但那只是意味着浪费时间在注意一些不重要的细节而不是着手于下一个任务。 </p>
<p>  工作狂不是英雄。他们不是在节约时间而是在浪费。真正的英雄已经回到家中,因为她找到更快的方法把工作做好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的文化颂扬工作狂思想。我们听说人们会午夜鏖战。他们开夜车而在办公室睡觉。 这被认为是一种把全身投入一个项目的标志。工作的总量不等于过量的工作。&lt;br&gt;这样的工作狂不仅没必要,而且很傻。做得多并不意味着你足够用心或者完成得更多。仅仅意味着你做得多。&lt;/p&gt;
&lt;p&gt;工作狂最
    
    </summary>
    
      <category term="书摘" scheme="http://mapeiyu.com/categories/%E4%B9%A6%E6%91%98/"/>
    
    
  </entry>
  
  <entry>
    <title>blog的hexo配置移植方法</title>
    <link href="http://mapeiyu.com/2016/10/09/hexo-blog-config/"/>
    <id>http://mapeiyu.com/2016/10/09/hexo-blog-config/</id>
    <published>2016-10-09T03:59:08.000Z</published>
    <updated>2017-02-13T06:17:39.048Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何将个人博客的hexo后台移植到另外的设备上, 使可以多平台上可以同步操作博客后台.</p>
<h3 id="0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github"><a href="#0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github" class="headerlink" title="0. 进入到你的hexo目录, 执行git init 生成git仓库, 将git仓库上传到github."></a>0. 进入到你的hexo目录, 执行git init 生成git仓库, 将git仓库上传到github.</h3><pre><code>//初始化仓库
cd hexo
git init
//提交init
git add .gitignore
git add .npmignore
git add _config.yml
git add source/
git add themes/
git commit -a -m init
//上传github服务器, 首先你要在github上添加了新的远程仓库
git remote add github git@gitlab.meizu.com:xxxx/xxxx.git
push -u github master
</code></pre><p>将配置文件上传至github, 看我的配置文件为<a href="https://github.com/masonTool/blog_config" target="_blank" rel="external">GITHUB</a></p>
<h3 id="1-进入移植设备-将本工程下拉-会生成目录blog-config"><a href="#1-进入移植设备-将本工程下拉-会生成目录blog-config" class="headerlink" title="1. 进入移植设备. 将本工程下拉, 会生成目录blog_config"></a>1. 进入移植设备. 将本工程下拉, 会生成目录blog_config</h3><pre><code>mkdir temp
git clone git@github.com:masonTool/blog_config.git
</code></pre><h3 id="2-再拷贝一份blog-config-命名为blog-config1-进入目录"><a href="#2-再拷贝一份blog-config-命名为blog-config1-进入目录" class="headerlink" title="2. 再拷贝一份blog_config(命名为blog_config1), 进入目录"></a>2. 再拷贝一份blog_config(命名为blog_config1), 进入目录</h3><pre><code>cp -r blog_config/ blog_config1
cd blog_config1
</code></pre><h3 id="3-依次执行指令"><a href="#3-依次执行指令" class="headerlink" title="3. 依次执行指令"></a>3. 依次执行指令</h3><pre><code>npm install hexo --save
hexo init
npm install hexo-deployer-git --save
</code></pre><h3 id="4-执行完上一步-会生成文件夹node-modules-文件夹中应该有如下的文件"><a href="#4-执行完上一步-会生成文件夹node-modules-文件夹中应该有如下的文件" class="headerlink" title="4. 执行完上一步, 会生成文件夹node_modules, 文件夹中应该有如下的文件"></a>4. 执行完上一步, 会生成文件夹node_modules, 文件夹中应该有如下的文件</h3><pre><code>hexo
hexo-deployer-git
dhexo-generator-archive
hexo-generator-category
hexo-generator-index
hexo-generator-tag
hexo-renderer-ejs
hexo-renderer-marked
hexo-renderer-stylus
hexo-server
</code></pre><h3 id="5-移动node-modules到原blog-config文件中-再删除blog-config1"><a href="#5-移动node-modules到原blog-config文件中-再删除blog-config1" class="headerlink" title="5. 移动node_modules到原blog_config文件中. 再删除blog_config1"></a>5. 移动node_modules到原blog_config文件中. 再删除blog_config1</h3><p>完成了移植. 此时你可以在多设备上写文章. 通过git来管理配置了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何将个人博客的hexo后台移植到另外的设备上, 使可以多平台上可以同步操作博客后台.&lt;/p&gt;
&lt;h3 id=&quot;0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github&quot;&gt;&lt;a href=&quot;#0-进入到你的hexo目录-执行git
    
    </summary>
    
      <category term="博客开发" scheme="http://mapeiyu.com/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="hexo" scheme="http://mapeiyu.com/tags/hexo/"/>
    
      <category term="github" scheme="http://mapeiyu.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflect Tool</title>
    <link href="http://mapeiyu.com/2016/10/08/java-reflect-tool/"/>
    <id>http://mapeiyu.com/2016/10/08/java-reflect-tool/</id>
    <published>2016-10-08T12:53:02.000Z</published>
    <updated>2017-02-13T06:17:11.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>  Java reflect operation always confuse me, cause is not so intuitive. And it’s low efficiency lead us can not use it very frequently. This reflect tool can help you simplify the operation and cache the reflect results. Hope can help you.</p>
<h2 id="Library-projects"><a href="#Library-projects" class="headerlink" title="Library projects"></a>Library projects</h2><p>See the project in <a href="https://github.com/masonTool/reflect" target="_blank" rel="external">GITHUB</a></p>
<p>Download <a href="https://search.maven.org/remote_content?g=com.github.masontool&amp;a=reflect&amp;v=LATEST" target="_blank" rel="external">the latest JAR</a> or grab via Maven:</p>
<p>For gradle:</p>
<pre><code>compile &apos;com.github.masontool:reflect:2.1.0&apos;
</code></pre><p>For maven:</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.github.masontool&lt;/groupId&gt;
  &lt;artifactId&gt;reflect&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="Useful"><a href="#Useful" class="headerlink" title="Useful"></a>Useful</h2><p>I can show you the sample , it’s simple;</p>
<p>ClassA:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassA {
    protected static String staticString = &quot;HELLO&quot;;
    private String normalString = &quot;WORLD&quot;;
    private static Integer plus(Integer a, Integer b) {
        return a+b;
    }
    private long minus(long a, long b) {
        return a - b;
    }
    private static int plus(ClassB b, ClassC c) {
        return b.value + c.value;
    }
}
</code></pre><p>ClassB:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassB {
    int value = 5;
}
</code></pre><p>ClassC:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassC {
    int value = 4;
}
</code></pre><p>We suppose all the classes, parameters, methods should be reflected. You can do like this:</p>
<ol>
<li><p>Get / Set static value in class.</p>
<pre><code>RClass clazzA = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassA&quot;);
clazzA.setValue(&quot;staticString&quot;, &quot;static changed!!!!!&quot;);
String staticString = clazzA.getValue(&quot;staticString&quot;);
</code></pre></li>
<li><p>Get / Set normal value in class.</p>
<pre><code>RInstance instanceA = clazzA.newWrappedInstance();
instanceA.setValue(&quot;normalString&quot;, &quot;normal changed!!!!!&quot;);
String normalString = instanceA.getValue(&quot;normalString&quot;);
</code></pre></li>
<li><p>Excute static method.</p>
<pre><code>Integer plusResult = clazzA.execute(&quot;plus&quot;, Integer.class, 5, Integer.class, 4);
</code></pre></li>
<li><p>Excute normal method.</p>
<pre><code>long minusResult = instanceA.execute(&quot;minus&quot;, long.class, 5, long.class, 4);
</code></pre></li>
<li><p>Support nested call. Here is a complex sample</p>
<pre><code>RClass clazzB = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassB&quot;);
RClass clazzC = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassC&quot;);
int complexResult1 = clazzA.execute(&quot;plus&quot;,
        clazzB, clazzB.newInstance(),
        clazzC, clazzC.newInstance());
</code></pre></li>
</ol>
<h2 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h2><p>   Any question you can contact me with email 307416073@qq.com.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;  Java reflect operation always confus
    
    </summary>
    
      <category term="原创组件" scheme="http://mapeiyu.com/categories/%E5%8E%9F%E5%88%9B%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="java" scheme="http://mapeiyu.com/tags/java/"/>
    
      <category term="android" scheme="http://mapeiyu.com/tags/android/"/>
    
      <category term="reflect" scheme="http://mapeiyu.com/tags/reflect/"/>
    
  </entry>
  
</feed>

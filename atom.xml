<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唧唧歪歪的河马正在打游戏</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mapeiyu.com/"/>
  <updated>2016-11-30T09:45:08.952Z</updated>
  <id>http://mapeiyu.com/</id>
  
  <author>
    <name>马培羽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RX操作符概述</title>
    <link href="http://mapeiyu.com/2016/11/07/rx-operation/"/>
    <id>http://mapeiyu.com/2016/11/07/rx-operation/</id>
    <published>2016-11-07T10:43:34.000Z</published>
    <updated>2016-11-30T09:45:08.952Z</updated>
    
    <content type="html"><![CDATA[<p>ReactiveX的每种编程语言的实现都实现了一组操作符的集合。不同的实现之间有很多重叠的部分，也有一些操作符只存在特定的实现中。每种实现都倾向于用那种编程语言中他们熟悉的上下文中相似的方法给这些操作符命名。</p>
<p>本文首先会给出ReactiveX的核心操作符列表和对应的文档链接，后面还有一个决策树用于帮助你根据具体的场景选择合适的操作符。最后有一个语言特定实现的按字母排序的操作符列表。</p>
<p>如果你想实现你自己的操作符，可以参考这里：实现自定义操作符</p>
<p>创建操作</p>
<p>用于创建Observable的操作符</p>
<p>Create — 通过调用观察者的方法从头创建一个Observable<br>Defer — 在观察者订阅之前不创建这个Observable，为每一个观察者创建一个新的Observable<br>Empty/Never/Throw — 创建行为受限的特殊Observable<br>From — 将其它的对象或数据结构转换为Observable<br>Interval — 创建一个定时发射整数序列的Observable<br>Just — 将对象或者对象集合转换为一个会发射这些对象的Observable<br>Range — 创建发射指定范围的整数序列的Observable<br>Repeat — 创建重复发射特定的数据或数据序列的Observable<br>Start — 创建发射一个函数的返回值的Observable<br>Timer — 创建在一个指定的延迟之后发射单个数据的Observable<br>变换操作</p>
<p>这些操作符可用于对Observable发射的数据进行变换，详细解释可以看每个操作符的文档</p>
<p>uffer — 缓存，可以简单的理解为缓存，它定期从Observable收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个<br>latMap — 扁平映射，将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，可以认为是一个将嵌套的数据结构展开的过程。<br>roupBy — 分组，将原来的Observable分拆为Observable集合，将原始Observable发射的数据按Key分组，每一个Observable发射一组不同的数据<br>ap — 映射，通过对序列的每一项都应用一个函数变换Observable发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项<br>can — 扫描，对Observable发射的每一项数据应用一个函数，然后按顺序依次发射这些值<br>indow — 窗口，定期将来自Observable的数据分拆成一些Observable窗口，然后发射这些窗口，而不是每次发射一项。类似于Buffer，但Buffer发射的是数据，Window发射的是Observable，每一个Observable发射原始Observable的数据的一个子集<br>过滤操作</p>
<p>这些操作符用于从Observable发射的数据中进行选择</p>
<p>Debounce — 只有在空闲了一段时间后才发射数据，通俗的说，就是如果一段时间没有操作，就执行一次操作<br>Distinct — 去重，过滤掉重复数据项<br>ElementAt — 取值，取特定位置的数据项<br>Filter — 过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的<br>First — 首项，只发射满足条件的第一条数据<br>IgnoreElements — 忽略所有的数据，只保留终止通知(onError或onCompleted)<br>Last — 末项，只发射最后一条数据<br>Sample — 取样，定期发射最新的数据，等于是数据抽样，有的实现里叫ThrottleFirst<br>Skip — 跳过前面的若干项数据<br>SkipLast — 跳过后面的若干项数据<br>Take — 只保留前面的若干项数据<br>TakeLast — 只保留后面的若干项数据<br>组合操作</p>
<p>组合操作符用于将多个Observable组合成一个单一的Observable</p>
<p>And/Then/When — 通过模式(And条件)和计划(Then次序)组合两个或多个Observable发射的数据集<br>CombineLatest — 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然- 后发射这个函数的结果<br>Join — 无论何时，如果一个Observable发射了一个数据项，只要在另一个Observable发射的数据项定义的时间窗口内，就将两个Observable发射的数据合并发射<br>Merge — 将两个Observable发射的数据组合并成一个<br>StartWith — 在发射原来的Observable的数据序列之前，先发射一个指定的数据序列或数据项<br>Switch — 将一个发射Observable序列的Observable转换为这样一个Observable：它逐个发射那些Observable最近发射的数据<br>Zip — 打包，使用一个指定的函数将多个Observable发射的数据组合在一起，然后将这个函数的结果作为单项数据发射<br>错误处理</p>
<p>这些操作符用于从错误通知中恢复</p>
<p>Catch — 捕获，继续序列操作，将错误替换为正常的数据，从onError通知中恢复<br>Retry — 重试，如果Observable发射了一个错误通知，重新订阅它，期待它正常终止<br>辅助操作</p>
<p>一组用于处理Observable的操作符</p>
<p>Delay — 延迟一段时间发射结果数据<br>Do — 注册一个动作占用一些Observable的生命周期事件，相当于Mock某个操作<br>Materialize/Dematerialize — 将发射的数据和通知都当做数据发射，或者反过来<br>ObserveOn — 指定观察者观察Observable的调度程序（工作线程）<br>Serialize — 强制Observable按次序发射数据并且功能是有效的<br>Subscribe — 收到Observable发射的数据和通知后执行的操作<br>SubscribeOn — 指定Observable应该在哪个调度程序上执行<br>TimeInterval — 将一个Observable转换为发射两个数据之间所耗费时间的Observable<br>Timeout — 添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知<br>Timestamp — 给Observable发射的每个数据项添加一个时间戳<br>Using — 创建一个只在Observable的生命周期内存在的一次性资源<br>条件和布尔操作</p>
<p>这些操作符可用于单个或多个数据项，也可用于Observable</p>
<p>All — 判断Observable发射的所有的数据项是否都满足某个条件<br>Amb — 给定多个Observable，只让第一个发射数据的Observable发射全部数据<br>Contains — 判断Observable是否会发射一个指定的数据项<br>DefaultIfEmpty — 发射来自原始Observable的数据，如果原始Observable没有发射数据，就发射一个默认数据<br>SequenceEqual — 判断两个Observable是否按相同的数据序列<br>SkipUntil — 丢弃原始Observable发射的数据，直到第二个Observable发射了一个数据，然后发射原始Observable的剩余数据<br>SkipWhile — 丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始Observable剩余的数据<br>TakeUntil — 发射来自原始Observable的数据，直到第二个Observable发射了一个数据或一个通知<br>TakeWhile — 发射原始Observable的数据，直到一个特定的条件为真，然后跳过剩余的数据<br>算术和聚合操作</p>
<p>这些操作符可用于整个数据序列</p>
<p>Average — 计算Observable发射的数据序列的平均值，然后发射这个结果<br>Concat — 不交错的连接多个Observable的数据<br>Count — 计算Observable发射的数据个数，然后发射这个结果<br>Max — 计算并发射数据序列的最大值<br>Min — 计算并发射数据序列的最小值<br>Reduce — 按顺序对数据序列的每一个应用某个函数，然后返回这个值<br>Sum — 计算并发射数据序列的和<br>连接操作</p>
<p>一些有精确可控的订阅行为的特殊Observable</p>
<p>Connect — 指示一个可连接的Observable开始发射数据给订阅者<br>Publish — 将一个普通的Observable转换为可连接的<br>RefCount — 使一个可连接的Observable表现得像一个普通的Observable<br>Replay — 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅<br>转换操作</p>
<p>To — 将Observable转换为其它的对象或数据结构<br>Blocking 阻塞Observable的操作符<br>操作符决策树</p>
<p>几种主要的需求</p>
<p>直接创建一个Observable（创建操作）<br>组合多个Observable（组合操作）<br>对Observable发射的数据执行变换操作（变换操作）<br>从Observable发射的数据中取特定的值（过滤操作）<br>转发Observable的部分值（条件/布尔/过滤操作）<br>对Observable发射的数据序列求值（算术/聚合操作）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactiveX的每种编程语言的实现都实现了一组操作符的集合。不同的实现之间有很多重叠的部分，也有一些操作符只存在特定的实现中。每种实现都倾向于用那种编程语言中他们熟悉的上下文中相似的方法给这些操作符命名。&lt;/p&gt;
&lt;p&gt;本文首先会给出ReactiveX的核心操作符列表和
    
    </summary>
    
      <category term="技术" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="转载" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="RX" scheme="http://mapeiyu.com/tags/RX/"/>
    
  </entry>
  
  <entry>
    <title>不做工作狂</title>
    <link href="http://mapeiyu.com/2016/10/15/Workaholism/"/>
    <id>http://mapeiyu.com/2016/10/15/Workaholism/</id>
    <published>2016-10-15T14:39:58.000Z</published>
    <updated>2016-11-30T09:45:18.028Z</updated>
    
    <content type="html"><![CDATA[<p>我们的文化颂扬工作狂思想。我们听说人们会午夜鏖战。他们开夜车而在办公室睡觉。 这被认为是一种把全身投入一个项目的标志。工作的总量不等于过量的工作。<br>这样的工作狂不仅没必要,而且很傻。做得多并不意味着你足够用心或者完成得更多。仅仅意味着你做得多。</p>
<p>工作狂最后制造的麻烦比解决的麻烦多。首先,工作狂好似没有合理利用时间。当筋疲力尽时,会制造更多麻烦。工作狂也抓不住要点。他们想用砸大把大把的时间来解决事情。他们想用蛮干来弥补一些小技巧。结果就是粗野的解决。</p>
<p>他们甚至会制造危机。他们不会去找高效的方法因为他们确实喜欢加班。他们享受英雄般的感觉。他们制造出问题(通常是无意识地)以便多多工作。工作狂若是不留到很晚会觉得仅仅花合理的时间工作是不合理的。这会四处充满内疚感和低士气。并且,产生理所当然的想法──留守很晚是职责之外的事,就算他们不是真的富有成效。<br>如果你所做的都是工作,你不太可能得到很好的评价。你的价值和决定会以误解告终。你不能判断额外的努力是值得还是不值得。你只会彻底累垮。没有人能疲倦中做出明晰的决定。<br>  最后,工作狂并不比非工作狂达成更多目标。他们也许会宣称自己是完美主义者,但那只是意味着浪费时间在注意一些不重要的细节而不是着手于下一个任务。 </p>
<p>  工作狂不是英雄。他们不是在节约时间而是在浪费。真正的英雄已经回到家中,因为她找到更快的方法把工作做好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们的文化颂扬工作狂思想。我们听说人们会午夜鏖战。他们开夜车而在办公室睡觉。 这被认为是一种把全身投入一个项目的标志。工作的总量不等于过量的工作。&lt;br&gt;这样的工作狂不仅没必要,而且很傻。做得多并不意味着你足够用心或者完成得更多。仅仅意味着你做得多。&lt;/p&gt;
&lt;p&gt;工作狂最
    
    </summary>
    
      <category term="生活" scheme="http://mapeiyu.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="转载" scheme="http://mapeiyu.com/categories/%E7%94%9F%E6%B4%BB/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="书摘" scheme="http://mapeiyu.com/tags/%E4%B9%A6%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title>blog的hexo配置移植方法</title>
    <link href="http://mapeiyu.com/2016/10/09/hexo-blog-config/"/>
    <id>http://mapeiyu.com/2016/10/09/hexo-blog-config/</id>
    <published>2016-10-09T03:59:08.000Z</published>
    <updated>2016-11-30T09:45:24.464Z</updated>
    
    <content type="html"><![CDATA[<p>介绍如何将个人博客的hexo后台移植到另外的设备上, 使可以多平台上可以同步操作博客后台.</p>
<h3 id="0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github"><a href="#0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github" class="headerlink" title="0. 进入到你的hexo目录, 执行git init 生成git仓库, 将git仓库上传到github."></a>0. 进入到你的hexo目录, 执行git init 生成git仓库, 将git仓库上传到github.</h3><pre><code>//初始化仓库
cd hexo
git init
//提交init
git add .gitignore
git add .npmignore
git add _config.yml
git add source/
git add themes/
git commit -a -m init
//上传github服务器, 首先你要在github上添加了新的远程仓库
git remote add github git@gitlab.meizu.com:xxxx/xxxx.git
push -u github master
</code></pre><p>将配置文件上传至github, 看我的配置文件为<a href="https://github.com/masonTool/blog_config" target="_blank" rel="external">GITHUB</a></p>
<h3 id="1-进入移植设备-将本工程下拉-会生成目录blog-config"><a href="#1-进入移植设备-将本工程下拉-会生成目录blog-config" class="headerlink" title="1. 进入移植设备. 将本工程下拉, 会生成目录blog_config"></a>1. 进入移植设备. 将本工程下拉, 会生成目录blog_config</h3><pre><code>mkdir temp
git clone git@github.com:masonTool/blog_config.git
</code></pre><h3 id="2-再拷贝一份blog-config-命名为blog-config1-进入目录"><a href="#2-再拷贝一份blog-config-命名为blog-config1-进入目录" class="headerlink" title="2. 再拷贝一份blog_config(命名为blog_config1), 进入目录"></a>2. 再拷贝一份blog_config(命名为blog_config1), 进入目录</h3><pre><code>cp -r blog_config/ blog_config1
cd blog_config1
</code></pre><h3 id="3-依次执行指令"><a href="#3-依次执行指令" class="headerlink" title="3. 依次执行指令"></a>3. 依次执行指令</h3><pre><code>npm install hexo --save
hexo init
npm install hexo-deployer-git --save
</code></pre><h3 id="4-执行完上一步-会生成文件夹node-modules-文件夹中应该有如下的文件"><a href="#4-执行完上一步-会生成文件夹node-modules-文件夹中应该有如下的文件" class="headerlink" title="4. 执行完上一步, 会生成文件夹node_modules, 文件夹中应该有如下的文件"></a>4. 执行完上一步, 会生成文件夹node_modules, 文件夹中应该有如下的文件</h3><pre><code>hexo
hexo-deployer-git
dhexo-generator-archive
hexo-generator-category
hexo-generator-index
hexo-generator-tag
hexo-renderer-ejs
hexo-renderer-marked
hexo-renderer-stylus
hexo-server
</code></pre><h3 id="5-移动node-modules到原blog-config文件中-再删除blog-config1"><a href="#5-移动node-modules到原blog-config文件中-再删除blog-config1" class="headerlink" title="5. 移动node_modules到原blog_config文件中. 再删除blog_config1"></a>5. 移动node_modules到原blog_config文件中. 再删除blog_config1</h3><p>完成了移植. 此时你可以在多设备上写文章. 通过git来管理配置了.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍如何将个人博客的hexo后台移植到另外的设备上, 使可以多平台上可以同步操作博客后台.&lt;/p&gt;
&lt;h3 id=&quot;0-进入到你的hexo目录-执行git-init-生成git仓库-将git仓库上传到github&quot;&gt;&lt;a href=&quot;#0-进入到你的hexo目录-执行git
    
    </summary>
    
      <category term="技术" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="原创" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="hexo" scheme="http://mapeiyu.com/tags/hexo/"/>
    
      <category term="github" scheme="http://mapeiyu.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflect Tool</title>
    <link href="http://mapeiyu.com/2016/10/08/java-reflect-tool/"/>
    <id>http://mapeiyu.com/2016/10/08/java-reflect-tool/</id>
    <published>2016-10-08T12:53:02.000Z</published>
    <updated>2016-11-30T09:45:31.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>  Java reflect operation always confuse me, cause is not so intuitive. And it’s low efficiency lead us can not use it very frequently. This reflect tool can help you simplify the operation and cache the reflect results. Hope can help you.</p>
<h2 id="Library-projects"><a href="#Library-projects" class="headerlink" title="Library projects"></a>Library projects</h2><p>See the project in <a href="https://github.com/masonTool/reflect" target="_blank" rel="external">GITHUB</a></p>
<p>Download <a href="https://search.maven.org/remote_content?g=com.github.masontool&amp;a=reflect&amp;v=LATEST" target="_blank" rel="external">the latest JAR</a> or grab via Maven:</p>
<p>For gradle:</p>
<pre><code>compile &apos;com.github.masontool:reflect:2.1.0&apos;
</code></pre><p>For maven:</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.github.masontool&lt;/groupId&gt;
  &lt;artifactId&gt;reflect&lt;/artifactId&gt;
  &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="Useful"><a href="#Useful" class="headerlink" title="Useful"></a>Useful</h2><p>I can show you the sample , it’s simple;</p>
<p>ClassA:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassA {
    protected static String staticString = &quot;HELLO&quot;;
    private String normalString = &quot;WORLD&quot;;
    private static Integer plus(Integer a, Integer b) {
        return a+b;
    }
    private long minus(long a, long b) {
        return a - b;
    }
    private static int plus(ClassB b, ClassC c) {
        return b.value + c.value;
    }
}
</code></pre><p>ClassB:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassB {
    int value = 5;
}
</code></pre><p>ClassC:</p>
<pre><code>package com.mason.meizu.sample.prvclass;
class ClassC {
    int value = 4;
}
</code></pre><p>We suppose all the classes, parameters, methods should be reflected. You can do like this:</p>
<ol>
<li><p>Get / Set static value in class.</p>
<pre><code>RClass clazzA = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassA&quot;);
clazzA.setValue(&quot;staticString&quot;, &quot;static changed!!!!!&quot;);
String staticString = clazzA.getValue(&quot;staticString&quot;);
</code></pre></li>
<li><p>Get / Set normal value in class.</p>
<pre><code>RInstance instanceA = clazzA.newWrappedInstance();
instanceA.setValue(&quot;normalString&quot;, &quot;normal changed!!!!!&quot;);
String normalString = instanceA.getValue(&quot;normalString&quot;);
</code></pre></li>
<li><p>Excute static method.</p>
<pre><code>Integer plusResult = clazzA.execute(&quot;plus&quot;, Integer.class, 5, Integer.class, 4);
</code></pre></li>
<li><p>Excute normal method.</p>
<pre><code>long minusResult = instanceA.execute(&quot;minus&quot;, long.class, 5, long.class, 4);
</code></pre></li>
<li><p>Support nested call. Here is a complex sample</p>
<pre><code>RClass clazzB = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassB&quot;);
RClass clazzC = new RClass(&quot;com.mason.meizu.sample.prvclass.ClassC&quot;);
int complexResult1 = clazzA.execute(&quot;plus&quot;,
        clazzB, clazzB.newInstance(),
        clazzC, clazzC.newInstance());
</code></pre></li>
</ol>
<h2 id="Feedback"><a href="#Feedback" class="headerlink" title="Feedback"></a>Feedback</h2><p>   Any question you can contact me with email 307416073@qq.com.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;p&gt;  Java reflect operation always confus
    
    </summary>
    
      <category term="技术" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="原创" scheme="http://mapeiyu.com/categories/%E6%8A%80%E6%9C%AF/%E5%8E%9F%E5%88%9B/"/>
    
    
      <category term="java" scheme="http://mapeiyu.com/tags/java/"/>
    
      <category term="android" scheme="http://mapeiyu.com/tags/android/"/>
    
      <category term="反射" scheme="http://mapeiyu.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
